----------------------------------------------------------------------------------
-- Company: 
-- Engineer: 
-- 
-- Create Date: 06/07/2020 05:37:04 PM
-- Design Name: 
-- Module Name: spi_ms - Behavioral
-- Project Name: 
-- Target Devices: 
-- Tool Versions: 
-- Description: 
-- 
-- Dependencies: 
-- 
-- Revision:
-- Revision 0.01 - File Created
-- Additional Comments:
-- 
----------------------------------------------------------------------------------


library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values

-- Uncomment the following library declaration if instantiating
-- any Xilinx leaf cells in this code.
--library UNISIM;
--use UNISIM.VComponents.all;
entity spi_ms is
  generic ( USPI_SIZE : integer;
            max_clk_div : integer);
  Port ( bclk : in std_logic;
         rstn : in std_logic;
         sndData : in std_logic_vector(USPI_SIZE-1 downto 0);
         rcvData : out std_logic_vector(USPI_SIZE-1 downto 0);
         sdi  : in std_logic;
         start : in std_logic;
         scsq : out std_logic;
         sclk : out std_logic;
         sdo  : out std_logic;
         done : out std_logic  );
end spi_ms;

architecture Behavioral of spi_ms is

type state is (sidle, sstartx, sstart_lo, sclk_hi, sclk_lo, stop_hi, stop_lo);
signal pr_state, nx_state : state;
signal scsq_i : std_logic;
signal wr_buf : std_logic_vector(USPI_SIZE-1 downto 0);
signal rd_buf : std_logic_vector(USPI_SIZE-1 downto 0) := (others=> '0');
signal count : integer range 0 to USPI_SIZE -1;
signal sclk_i : std_logic;
signal sdo_i : std_logic;
signal sclk_p : std_logic;

begin
rcvData <= rd_buf;

comb :process(pr_state, start, count, wr_buf)
begin
--default values for the signals
nx_state <= pr_state;
scsq_i <= '0';
sclk_i <= '0';
done  <= '0';
sdo_i <= '0';
    
    case pr_state is
        when sidle =>
            done <= '1';
            scsq_i <= '1';
            if(start = '1') then
                nx_state <= sstartx;
            end if;            
            
        when sstartx =>
            nx_state <= sstart_lo;
            
        when sstart_lo =>
            sdo_i <= wr_buf(USPI_SIZE-1);
            sclk_i <= '1';
            nx_state <= sclk_hi;
            
        when sclk_hi =>
            sdo_i <= wr_buf(USPI_SIZE-1); 
            nx_state <= sclk_lo;
        
        when sclk_lo =>
              sclk_i <= '1';
              sdo_i <= wr_buf(USPI_SIZE-1);          
            if ( count = 0 ) then
                nx_state <= stop_hi;
            else 
                nx_state <= sclk_hi;
            end if;
            
        when stop_hi =>
            sdo_i <= wr_buf(USPI_SIZE-1); 
            nx_state <= stop_lo;

        when stop_lo =>
            scsq_i <= '1';
            nx_state <= sidle;
            
    end case;
end process comb;

seq: process(bclk, sdi)
begin
    if (rising_edge(bclk)) then 
        if(rstn = '0') then
            pr_state <= sidle; 
        elsif (sclk_p = '1') then
            if(nx_state = sstartx) then
                wr_buf <= sndData;   
                count <= USPI_SIZE-1;
            elsif(nx_state = sclk_hi) then
                count <= count - 1;           
            elsif(nx_state = sclk_lo) then
                rd_buf <= rd_buf(USPI_SIZE-2 downto 0) & sdi;
                wr_buf <= std_logic_vector(shift_left(unsigned(wr_buf), 1));
            elsif(nx_state = stop_lo) then
                rd_buf <= rd_buf(USPI_SIZE-2 downto 0) & sdi;
            end if;
        pr_state <= nx_state;
        scsq <= scsq_i;
        sclk <= sclk_i;
        sdo <= sdo_i;
        end if;
    end if;       
end process seq;

clk_div: process (bclk)
variable clk_div : integer range 0 to max_clk_div-1 := max_clk_div-1;
begin

if rising_edge(bclk) then
    if (clk_div = 0) then
        sclk_p <= '1';
        clk_div := max_clk_div-1;
    elsif (clk_div > 0) then
        clk_div := clk_div - 1;
        sclk_p <= '0';
    end if;
end if;
end process clk_div;

end Behavioral;
